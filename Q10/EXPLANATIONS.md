# Question 10 – Commands and Explanations

## Creating the C program

Command:  
`nano signal_demo.c`  
Explanation: I opened the nano text editor to create the C source file signal_demo.c which will demonstrate signal handling between a parent process and its child processes.

Command:  
*(inside nano I typed the full signal_demo.c program and then saved and exited)*  
Explanation: I wrote a C program where the parent installs handlers for SIGTERM and SIGINT, then creates two child processes: one child sends SIGTERM to the parent after 5 seconds and the other child sends SIGINT after 10 seconds, while the parent keeps running and printing messages until a signal is received.

---

## Compiling the program

Command:  
`gcc signal_demo.c -o signal_demo`  
Explanation: I used the gcc compiler to compile signal_demo.c and create an executable named signal_demo. If there are no errors, this command produces the binary file that I can run.

---

## Running the program

Command:  
`./signal_demo`  
Explanation: I executed the compiled program. The parent printed its PID and kept printing “Parent: still running ...” messages in a loop. Child 1 printed that it would send SIGTERM after 5 seconds, waited, then sent SIGTERM to the parent and exited. The parent’s SIGTERM handler printed a message saying it received SIGTERM and started graceful shutdown, set a flag, and then the main loop ended with the final line “Parent: exiting gracefully now.” This shows that the parent handled the signal and exited cleanly instead of terminating abruptly.




# Question 10 – Code Explanation (signal_demo.c)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
These header files provide the standard I/O functions, general utilities, process management functions (like fork(), getpid(), sleep()), and the signal-related functions and types used in the program.


volatile sig_atomic_t terminate_flag = 0;
I declare a global flag of type sig_atomic_t so it can be safely modified inside signal handlers. This flag tells the parent when it should stop its main loop and exit.


void handle_sigterm(int sig) {
    (void)sig;
    printf("Parent: Received SIGTERM, starting graceful shutdown...\n");
    terminate_flag = 1;
}
This is the handler for SIGTERM. When the parent receives SIGTERM, it prints a message and sets terminate_flag to 1 instead of exiting immediately, which allows the main loop to finish gracefully.


void handle_sigint(int sig) {
    (void)sig;
    printf("Parent: Received SIGINT, cleaning up and exiting immediately...\n");
    terminate_flag = 1;
}
This is the handler for SIGINT. It also prints a different message and sets the same terminate_flag, but the text explains that the parent is exiting immediately, showing a different response to a different signal.


int main(void) {
    pid_t child1, child2;

    printf("Parent: PID %d, starting and will run until signals arrive.\n", getpid());
The main function starts by printing the parent’s PID and stating that it will continue running until it receives signals from its children.


    if (signal(SIGTERM, handle_sigterm) == SIG_ERR) {
        perror("Error setting SIGTERM handler");
        exit(1);
    }
    if (signal(SIGINT, handle_sigint) == SIG_ERR) {
        perror("Error setting SIGINT handler");
        exit(1);
    }
Here I install the custom signal handlers for SIGTERM and SIGINT using the signal() function. If setting either handler fails, the program prints an error and exits.


    child1 = fork();
    if (child1 < 0) {
        perror("fork failed");
        exit(1);
    } else if (child1 == 0) {
        printf("Child 1 (PID %d): will send SIGTERM to parent after 5 seconds.\n", getpid());
        sleep(5);
        kill(getppid(), SIGTERM);
        printf("Child 1 (PID %d): sent SIGTERM to parent and will exit.\n", getpid());
        exit(0);
    }
I create the first child process with fork(). In the child (pid == 0), it prints a message, sleeps for 5 seconds, then sends SIGTERM to the parent using kill(getppid(), SIGTERM), prints that it has sent the signal, and exits.


    child2 = fork();
    if (child2 < 0) {
        perror("fork failed");
        exit(1);
    } else if (child2 == 0) {
        printf("Child 2 (PID %d): will send SIGINT to parent after 10 seconds.\n", getpid());
        sleep(10);
        kill(getppid(), SIGINT);
        printf("Child 2 (PID %d): sent SIGINT to parent and will exit.\n", getpid());
        exit(0);
    }
I then create the second child process. This child waits for 10 seconds, sends SIGINT to the parent, prints a confirmation message, and exits. This shows a different signal being generated by another child.


    while (!terminate_flag) {
        printf("Parent: still running (PID %d)...\n", getpid());
        sleep(1);
    }
The parent enters a loop where it keeps printing that it is still running once per second. It stays in this loop until terminate_flag becomes 1, which happens when either SIGTERM or SIGINT is handled.


    printf("Parent: exiting gracefully now.\n");
    return 0;
}
When a signal handler sets terminate_flag, the loop ends and the parent prints a final message that it is exiting gracefully, then returns 0 from main, indicating a clean shutdown after handling the signals.
